## 操作系统-进程

1. ## 基本概念

    ![image-20190927201723456](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-09-27-121723.png)

    ![image-20190927195751369](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-09-27-115751.png)

    - 程序的执行特征:

    - 顺序执行:

    1. 顺序性
    2. 封闭性
    3. 可再现性:同样的输入同样的程序,输出也一样(并发执行不可再现)

    - 前趋图中不存在循环

    - 并发执行:

    1. 间断性

    进程的引入是为了更好地描述程序并发执行的动态特征,是一个动态的概念

    **进程是**:

    - 程序或 CPU的一次执行过程

    - 系统进行资源调度和分配的一个独立单位

    - 动态的概念

    ***PCB:记录和描述进程的动态特性，描述进程的执行情况和状态变化。***

    为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为[进程控制块](https://baike.baidu.com/item/进程控制块/7205297)（PCB Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。用于描述当前情况以及管理进程运行的全部信息.是一种记录型数据结构.

    PCB 常驻内存

    创建进程就是创建 PCB:

    - 1. 独立运行的基本标准
    2. 实现间断运行方式

    特征:

    - 动态性—进程是程序执行过程具有生命周期
    - 并发性— PCB
    - 独立性— 一个进程是系统分配资源和能够被处理机调度的一个基本单位**独立运行，独立获得资源。**
    - 异步性—不可预知的速度

    #### 进程的状态

    - 就绪状态--进程已经分配到除了CPU以外所有必要资源
    - 执行状态--获得CPU，正在运行
    - 阻塞状态—正在执行的进程因为意外而无法继续执行
    - 挂起状态--![image-20190927205901855](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-09-27-125902.png)

    - 索引:比链接的方式更快

    在索引表中记录 PCB 的地址

2. ## 进程控制

    - 定义:进程控制是进程管理中最基本的功能，他用于创建一个新进程，终止一个已完成的进程，或去终止一个因出现某事件而使其无法进行下去的进程，还可以负责进程运行中的状态转换。

    - 进程创建

    - 进程终止

    - 进程阻塞--修改 PCB,将进程 PCB 加入阻塞队列--block

    - 唤醒是系统自动的--修改PCB，入就绪队列--wakeup

    - 进程的挂起与激活

    挂起--suspend

    激活--active

    - 1.进程的概念:进程是操作系统最重要，最基本的概念之一， 

    它是可并发执行的程序在给定数据集合上的一次执行过程，是系 统分配资源和调度的一个独立的基本单位和实体。PCB块是进程存 在的唯一标志。 

    2.进程的特征:进程具有**动态性、并发性、独立性及异步性** 等基本特征。动态性反映在进程从创建到撤消的生命期。 

    3.进程状态转换及其条件:对进程生命期的各种活 动、状态的转变及控制，由构成操作系统内核的各种原语实现。 进程的并发性反映在对资源的竟争而产生的相互约束上。 

3. ## 进程同步

    大题,50 分那种

    基本概念:使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有***可再现性。***

    >
    >
    >进程同步的基本概念
    >
    >- 两种形式的制约关系
    >- 临界资源、临界区一导入实例
    >- 同步机制应遵循的规则
    >
    >信号量机制一问题导入
    >
    >- 整型信号量
    >- 记录型信号量
    >- AND 型信号量集、一般信号量集
    >
    >信号量的应用一总结方法
    >
    >- 信号量实现进程互斥
    >- 信号量描述进程间的前趋关系. 

    ---

    ## 并发间进程的关系:

    互斥关系一**进程之间排它使用资源**

    - 间接相互制约关系(只要带**共享**两个字)
    - 用信号量机制解决

    同步关系一**进程之间按照某种时序（一定的先后次序）执行**

    - 直接相互制约关系

    ---

    临界资源:凡是以互斥方式使用的共享资源都称为临界资源。一次只允许一个进程使用

    生产者消费者问题

    需要一个队列,用于控制 flag

    (in+1)%n

    ---

    ## 四个规则:

    - > 空闲让进:
    >
        > - 无进程处于临界区内时，可让一个申请进入该临界区的进程进入
    >
        > 忙则等待:
    >
        > - 临界区内有进程时，中请进入临界区的进程必须等待。
    >
        > 有限等待:
    >
        > - 进程进入临界区的请求，必须在有限的时间内满足。
    >
        > 让权等待:
    >
        > - 等待（不能）进入临界区的进程，必须立即释放 CPU.

    ---

    50 分的信号量机制

    信号量机构是一种功能较强的机制，可用来解决互斥与同步的问题。在长期且广泛的应用中，信号量机制得到了很大的发展。由最初的整形信号量，经过记录性信号量、AND信号量，最后发展为“信号量集”。

定义：VAR S: Semaphore;—**信号量:资源的数量**

## operation 原语

1. wait(P 操作):

    Wait (S）一对信号量 S 进行 wait 操作。

    wait 操作：（减 1 操作），申请分配一个单位的资源

2. Signal 操作（V 操作）

    signal (S）一对信号量 S 进行 signal 操作

    Signal 操作：（加 1 操作），释放一个单位的资源

- ## 整型信号量

    整型信号量一一非负整数，除了初始化外，只能通过两个原子操作 Wait 和 signal (P, V）来访问

    ```cpp
     wait(S){
         while (S<=0);
         S=S-1;
     }//p操作
     signal(S){
         S=S+1;
     }//v操作
    
    ```

    wait操作中，只要信号量S<=0，就会不断地测试。因此，该机制并未遵循“让权等待” 的准则，而是使进程处于“忙等”的状态。

- ## 记录型信号量

    1、设置一个代表资源数目的整型变量 value（资源信号量）

    2、设置一链表 L 用于链接所有等待的进程

    ```cpp
     typedef struct{
         int value;
         struct process *L;
     } semaphore
    ```

    - 相应的wait(S)和signal(S)的操作如下：

    - wait操作，S.value--，表示进程请求一个该类资源，当S.value<0时，表示该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入到该类资源的等待队列S.L中，可见该机制遵循了“让权等待”的准则。

        ```csharp
         void wait (semaphore S) { //相当于申请资源
             S.value--;
             if(S.value<0) {
                 add this process to S.L;
                 block(S.L);
             }
         }
        ```

        S=-1时,有一个进程阻塞

        s=-2 时,有 2 个进程阻塞

    - signal操作，表示进程释放一个资源，使系统中可供分配的该类资源数增1，故S.value++。若加1后仍是S.value<=0，则表示在S.L中仍有等待该资源的进程被阻塞，故还应调用wakeup 原语，将S.L中的第一个等待进程唤醒。

    - ```csharp
         void signal (semaphore S) { //相当于释放资源
             S.value++;
             if(S.value<=0){
                 remove a process P from S.L;
                 wakeup(P);
             }
         }
         ```
    
    ![image-20190929204359516](/Users/Macbook/Library/Application Support/typora-user-images/image-20190929204359516.png)
    
- 例题:
  
- ```
         S:semaphore S=1
         
         P1:
         	wait(S)
         	CS
         	signal(S)
         	
         P2:
         	wait(S)
         	CS
         	signal(S)
     ```
    
    ---
    
    - ## AND信号量
    
        上述进程互斥问题都是针对一个临界资源而言的，在有些应用场合，一个进程需要同时获得两个或者更多的资源。AND信号量可以解决多临界资源申请问题。假设有S1，...Sn，N个资源，进程必须申请到所有资源后才可执行，则其wait 和signal描述为：
    
        ```csharp
         void wait(S1, S2, ... , Sn){
             if (S1>=1 && S2>=1 && ... && Sn>=1 )
                 for (int i=1; i<n; i++)
                     Si = Si - 1;
             else 
                 place this process//将当前进程放置在第一个不满足Si>=1的阻塞队列中      
         }
         void signal(S1, S2, ... , Sn){
             for (int i=1; i<n; i++)
                 Si = Si + 1;
             romove all the process waiting in the queue associated with Si into ready queue
         }
        ```
    
    ​    基本思想：原子性要么全分配，要么一个也不分配
    
    ​    
    
    ---
    
    ##### 信号集
    
    1.  Swait  (S, d, d)
    
        此时的信号量集已蜕化为一般信号量，但它允许每次中请 d 个资源，当现有资源数少于 d 时，不予分配.
    
	2. Swait  (S, 1, 1)
    此时的信号量集又蜕化为计录型信号量（S>1 时）或互斥信号量（S=1 时）;  
      
	3.  Swait (S,1,0)
    
        当 S>1 时，允许多个进程进入某特定区；当 S 变为 0 后，将阻止任何进程进入特定区。即它相当于一个“可控开关”。
    
    ---
    
    ##### 利用信号量来描述前趋关系
    
    问题:设有两个并发进程P1和P2,P1中有语句S1, P2中有语句S2,要求S1执行后S2再执行
    
    Answer:设一公用信号量 S，初值为 0 
    
    ​				进程 P1: S1; signal(S)；
    
    ​				进程 P2: Wait (S); S2;
    
    ![image-20190929205239814](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-09-29-125240.png)

1. ## 经典的进程同步问题

    1. #### 生产者消费者问题

        最著名的进程同步问题。它描述了一组生产者向一组消费者提供产品，它们共享一个有界缓冲区，生产者向其中投放产品，消费者从中取得产品。它是许多相互合作进程的抽象，如输入进程与计算进程；计算进程与打印进程等。

        ![image-20190929210648887](/Users/Macbook/Library/Application Support/typora-user-images/image-20190929210648887.png)

        有两个队列,empty 和 full

        ![image-20191011184422876](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-10-11-104423.png)
        
        ---
        
        1. 定义信号量semaphore 机制并赋初值
        2. 进程,过程
        3. 信号量机制
        4. 检测

    ---

    #### B. 哲学家进餐

    问题:有五个哲学家，他们的生活方式是交替地进行思考和进餐。他
    们共用一张圆桌，分别坐在五张椅子上。在圆桌上有五个碗和五支筷子，平时一个哲学家进行思考，饥饿时便试图取用其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐。进餐毕，放下筷子又继续思考。

    > 1. 只有拿起两只筷子才可进餐
    > 2. 进餐完毕，放下筷子继续思考
    > 3. 若筷子在他人手中，则等待

    有 5 个哲学家,所以应该有 5 个进程

    #### 制约关系:

    思考:无制约

    拿筷子:有制约

    进餐:无制约

    ---

    ```python
    方案(错):所有人拿筷子的时候都是先拿左边,再拿右边
    
    定义信号量:chipstick[i]:1,1,1,1,1
    #先左后右
    P(i):
    	wait(chopstick[i]);
    	wait(chopstick[(i+1)%5]);
        Eat();
        signal(chopstick [i]);
    	signal( chopstick [(i+1)%5]);
        think();
        
    ```

    改进 AND 机制

    ```
    Semphore chopstick [5] = {1,1,1, 1, 1};
    
    do{
    think;
    Swait(chopstick[(i+1) %5], chopstick [i]);
    eat;
    Ssignal(chopstick [(i+1) %5], chopstick [i]);
    }while (TURE)
    ```

    ---

    ## 读者写者问题

    有两组并发进程:读者进程(只读)，写者进程(只写) 共享一个文件(资源)对象。读、写规则如下: 

    - 允许多个“读者”同时执行读操作。 Rmutex 

    - 任一“写者”访问文件时，不允许其他“读者”或“写者 ”工作。Wmutex

    ![image-20191011194154564](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-10-11-114155.png)

    ![image-20191011195218042](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-10-11-115219.png)

    ---

2. ## 管程机制

管理程序 (**monitor**) 是更高级的同步机制，能够进一步实现复杂的并发性问题。 

运用面对对象的思维把信号量机制封装起来

管程的定义一一个数据结构和在该数据结构上能被并发进程所执行的一组操作，这鉏操作能同步进程和改变管程中的数据.









## 作业

![image-20191011195721924](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-10-11-115722.png)

![image-20191011195704591](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-10-11-115704.png)

![image-20191011205147502](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-10-11-125147.png)