## 操作系统-进程

1. ## 基本概念

    ![image-20190927201723456](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-09-27-121723.png)

    ![image-20190927195751369](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-09-27-115751.png)

    - 程序的执行特征:

    - 顺序执行:

    1. 顺序性
    2. 封闭性
    3. 可再现性:同样的输入同样的程序,输出也一样(并发执行不可再现)

    - 前趋图中不存在循环

    - 并发执行:

    1. 间断性

    进程的引入是为了更好地描述程序并发执行的动态特征,是一个动态的概念

    **进程是**:

    - 程序或 CPU的一次执行过程

    - 系统进行资源调度和分配的一个独立单位

    - 动态的概念

    ***PCB:记录和描述进程的动态特性，描述进程的执行情况和状态变化。***

    为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为[进程控制块](https://baike.baidu.com/item/进程控制块/7205297)（PCB Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。用于描述当前情况以及管理进程运行的全部信息.是一种记录型数据结构.

    PCB 常驻内存

    创建进程就是创建 PCB:

    - 1. 独立运行的基本标准
    2. 实现间断运行方式

    特征:

    - 动态性—进程是程序执行过程具有生命周期
    - 并发性— PCB
    - 独立性— 一个进程是系统分配资源和能够被处理机调度的一个基本单位**独立运行，独立获得资源。**
    - 异步性—不可预知的速度

    #### 进程的状态

    - 就绪状态--进程已经分配到除了CPU以外所有必要资源
    - 执行状态--获得CPU，正在运行
    - 阻塞状态—正在执行的进程因为意外而无法继续执行
    - 挂起状态--![image-20190927205901855](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-09-27-125902.png)

    - 索引:比链接的方式更快

    在索引表中记录 PCB 的地址

2. ## 进程控制

    - 定义:进程控制是进程管理中最基本的功能，他用于创建一个新进程，终止一个已完成的进程，或去终止一个因出现某事件而使其无法进行下去的进程，还可以负责进程运行中的状态转换。

    - 进程创建

    - 进程终止

    - 进程阻塞--修改 PCB,将进程 PCB 加入阻塞队列--block

    - 唤醒是系统自动的--修改PCB，入就绪队列--wakeup

    - 进程的挂起与激活

    挂起--suspend

    激活--active

    - 1.进程的概念:进程是操作系统最重要，最基本的概念之一， 

    它是可并发执行的程序在给定数据集合上的一次执行过程，是系 统分配资源和调度的一个独立的基本单位和实体。PCB块是进程存 在的唯一标志。 

    2.进程的特征:进程具有**动态性、并发性、独立性及异步性** 等基本特征。动态性反映在进程从创建到撤消的生命期。 

    3.进程状态转换及其条件:对进程生命期的各种活 动、状态的转变及控制，由构成操作系统内核的各种原语实现。 进程的并发性反映在对资源的竟争而产生的相互约束上。 

3. ## 进程同步

    大题,50 分那种

    基本概念:使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有***可再现性。***

    >
    >
    >进程同步的基本概念
    >
    >- 两种形式的制约关系
    >- 临界资源、临界区一导入实例
    >- 同步机制应遵循的规则
    >
    >信号量机制一问题导入
    >
    >- 整型信号量
    >- 记录型信号量
    >- AND 型信号量集、一般信号量集
    >
    >信号量的应用一总结方法
    >
    >- 信号量实现进程互斥
    >- 信号量描述进程间的前趋关系. 

    ---

    ## 并发间进程的关系:

    互斥关系一**进程之间排它使用资源**

    - 间接相互制约关系(只要带**共享**两个字)
    - 用信号量机制解决

    同步关系一**进程之间按照某种时序（一定的先后次序）执行**

    - 直接相互制约关系

    ---

    临界资源:凡是以互斥方式使用的共享资源都称为临界资源。一次只允许一个进程使用

    生产者消费者问题

    需要一个队列,用于控制 flag

    (in+1)%n

    ---

    ## 四个规则:

    - > 空闲让进:
    >
        > - 无进程处于临界区内时，可让一个申请进入该临界区的进程进入
    >
        > 忙则等待:
    >
        > - 临界区内有进程时，中请进入临界区的进程必须等待。
    >
        > 有限等待:
    >
        > - 进程进入临界区的请求，必须在有限的时间内满足。
    >
        > 让权等待:
    >
        > - 等待（不能）进入临界区的进程，必须立即释放 CPU.

    ---

    50 分的信号量机制

    信号量机构是一种功能较强的机制，可用来解决互斥与同步的问题。在长期且广泛的应用中，信号量机制得到了很大的发展。由最初的整形信号量，经过记录性信号量、AND信号量，最后发展为“信号量集”。

定义：VAR S: Semaphore;—**信号量:资源的数量**

## operation 原语

1. wait(P 操作):

    Wait (S）一对信号量 S 进行 wait 操作。

    wait 操作：（减 1 操作），申请分配一个单位的资源

2. Signal 操作（V 操作）

    signal (S）一对信号量 S 进行 signal 操作

    Signal 操作：（加 1 操作），释放一个单位的资源

- ## 整型信号量

    整型信号量一一非负整数，除了初始化外，只能通过两个原子操作 Wait 和 signal (P, V）来访问

    ```cpp
     wait(S){
         while (S<=0);
         S=S-1;
     }//p操作
     signal(S){
         S=S+1;
     }//v操作
    
    ```

    wait操作中，只要信号量S<=0，就会不断地测试。因此，该机制并未遵循“让权等待” 的准则，而是使进程处于“忙等”的状态。

- ## 记录型信号量

    1、设置一个代表资源数目的整型变量 value（资源信号量）

    2、设置一链表 L 用于链接所有等待的进程

    ```cpp
     typedef struct{
         int value;
         struct process *L;
     } semaphore
    ```

    - 相应的wait(S)和signal(S)的操作如下：

    - wait操作，S.value--，表示进程请求一个该类资源，当S.value<0时，表示该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入到该类资源的等待队列S.L中，可见该机制遵循了“让权等待”的准则。

        ```csharp
         void wait (semaphore S) { //相当于申请资源
             S.value--;
             if(S.value<0) {
                 add this process to S.L;
                 block(S.L);
             }
         }
        ```

        S=-1时,有一个进程阻塞

        s=-2 时,有 2 个进程阻塞

    - signal操作，表示进程释放一个资源，使系统中可供分配的该类资源数增1，故S.value++。若加1后仍是S.value<=0，则表示在S.L中仍有等待该资源的进程被阻塞，故还应调用wakeup 原语，将S.L中的第一个等待进程唤醒。

    - ```csharp
         void signal (semaphore S) { //相当于释放资源
             S.value++;
             if(S.value<=0){
                 remove a process P from S.L;
                 wakeup(P);
             }
         }
         ```
    
    ![image-20190929204359516](/Users/Macbook/Library/Application Support/typora-user-images/image-20190929204359516.png)
    
- 例题:
  
- ```
         S:semaphore S=1
         
         P1:
         	wait(S)
         	CS
         	signal(S)
         	
         P2:
         	wait(S)
         	CS
         	signal(S)
     ```
    
    ---
    
    - ## AND信号量
    
        上述进程互斥问题都是针对一个临界资源而言的，在有些应用场合，一个进程需要同时获得两个或者更多的资源。AND信号量可以解决多临界资源申请问题。假设有S1，...Sn，N个资源，进程必须申请到所有资源后才可执行，则其wait 和signal描述为：
    
        ```csharp
         void wait(S1, S2, ... , Sn){
             if (S1>=1 && S2>=1 && ... && Sn>=1 )
                 for (int i=1; i<n; i++)
                     Si = Si - 1;
             else 
                 place this process//将当前进程放置在第一个不满足Si>=1的阻塞队列中      
         }
         void signal(S1, S2, ... , Sn){
             for (int i=1; i<n; i++)
                 Si = Si + 1;
             romove all the process waiting in the queue associated with Si into ready queue
         }
        ```
    
    ​    基本思想：原子性要么全分配，要么一个也不分配
    
    ​    
    
    ---
    
    ##### 信号集
    
    1.  Swait  (S, d, d)
    
        此时的信号量集已蜕化为一般信号量，但它允许每次中请 d 个资源，当现有资源数少于 d 时，不予分配.
    
	2. Swait  (S, 1, 1)
    此时的信号量集又蜕化为计录型信号量（S>1 时）或互斥信号量（S=1 时）;  
      
	3.  Swait (S,1,0)
    
        当 S>1 时，允许多个进程进入某特定区；当 S 变为 0 后，将阻止任何进程进入特定区。即它相当于一个“可控开关”。
    
    ---
    
    ##### 利用信号量来描述前趋关系
    
    问题:设有两个并发进程P1和P2,P1中有语句S1, P2中有语句S2,要求S1执行后S2再执行
    
    Answer:设一公用信号量 S，初值为 0 
    
    ​				进程 P1: S1; signal(S)；
    
    ​				进程 P2: Wait (S); S2;
    
    ![image-20190929205239814](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-09-29-125240.png)

1. ## 经典的进程同步问题

    1. #### 生产者消费者问题

        最著名的进程同步问题。它描述了一组生产者向一组消费者提供产品，它们共享一个有界缓冲区，生产者向其中投放产品，消费者从中取得产品。它是许多相互合作进程的抽象，如输入进程与计算进程；计算进程与打印进程等。

        ![image-20190929210648887](/Users/Macbook/Library/Application Support/typora-user-images/image-20190929210648887.png)

        有两个队列,empty 和 full

        ![image-20191011184422876](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-10-11-104423.png)
        
        ---
        
        1. 定义信号量semaphore 机制并赋初值
        2. 进程,过程
        3. 信号量机制
        4. 检测

    ---

    #### B. 哲学家进餐

    问题:有五个哲学家，他们的生活方式是交替地进行思考和进餐。他
    们共用一张圆桌，分别坐在五张椅子上。在圆桌上有五个碗和五支筷子，平时一个哲学家进行思考，饥饿时便试图取用其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐。进餐毕，放下筷子又继续思考。

    > 1. 只有拿起两只筷子才可进餐
    > 2. 进餐完毕，放下筷子继续思考
    > 3. 若筷子在他人手中，则等待

    有 5 个哲学家,所以应该有 5 个进程

    #### 制约关系:

    思考:无制约

    拿筷子:有制约

    进餐:无制约

    ---

    ```python
    方案(错):所有人拿筷子的时候都是先拿左边,再拿右边
    
    定义信号量:chipstick[i]:1,1,1,1,1
    #先左后右
    P(i):
    	wait(chopstick[i]);
    	wait(chopstick[(i+1)%5]);
        Eat();
        signal(chopstick [i]);
    	signal( chopstick [(i+1)%5]);
        think();
        
    ```

    改进 AND 机制

    ```
    Semphore chopstick [5] = {1,1,1, 1, 1};
    
    do{
    think;
    Swait(chopstick[(i+1) %5], chopstick [i]);
    eat;
    Ssignal(chopstick [(i+1) %5], chopstick [i]);
    }while (TURE)
    ```

    ---

    ## 读者写者问题

    有两组并发进程:读者进程(只读)，写者进程(只写) 共享一个文件(资源)对象。读、写规则如下: 

    - 允许多个“读者”同时执行读操作。 Rmutex 

    - 任一“写者”访问文件时，不允许其他“读者”或“写者 ”工作。Wmutex

    ![image-20191011194154564](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-10-11-114155.png)

    ![image-20191011195218042](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-10-11-115219.png)

    ---

2. ## 管程机制

管理程序 (**monitor**) 是更高级的同步机制，能够进一步实现复杂的并发性问题。 

运用面对对象的思维把信号量机制封装起来

管程的定义一一个数据结构和在该数据结构上能被并发进程所执行的一组操作，这鉏操作能同步进程和改变管程中的数据.









## 作业

![image-20191011195721924](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-10-11-115722.png)

![image-20191011195704591](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-10-11-115704.png)

![image-20191011205147502](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-10-11-125147.png)

---

比较线程和进程

决策模式
决策模式说明选择函数在执行的瞬间的处理方式，通常分为以下两类：

非抢占：一旦进入运行状态，就不会终止直到运行结束。

抢占：当前正在运行的进程可以被打断，并转移到就绪态。

 一个调度算法是否能抢占，对进程的顺序有着极大的影响。

先来先服务FCFS
  先来先服务是最简单的策略，也成为先进先出FIFO。首先它是一个非抢占的。如字面的意思，它根据进程到达时间决定先运行哪一个进程。

  这里给出一个实际的例子。以表格的形式表现出在FIFO策略下各进程的情况。



简单说就是依次执行完成，从时间轴上来看



以表格的形式展现：

 

其中开始时间是上一个进程的结束时间

      结束时间=开始时间+服务/执行时间

      周转周期=结束时间-到达时间

      带权周转时间=周转时间/服务时间

最短进程优先SPN
也称最短作业优先（Short Job First,SJF）。它也是一个非抢占的。是根据服务的时间经行选择。在这里要注意下到达时间的顺序。比如实例中单纯以大小来排序的话是E-A-C-D-B,但正确的排序一定是A-B为开头。以时间为顺序：

 

例子中A运行结束时间为3，这时只有B进程等待。所以A运行结束后直接运行B。B结束后时间点到9，CDE都在等待。这个时候就选择服务时间最少的E，然后是较少的C，最后是D。以表格的形式展示：

 

最短剩余时间优先SRT
SRT是针对SPN增加了抢占机制的版本，就好比例子中B运行时间非常长，在这期间其他所有的进程都在等待，如果将其中断，先处理所需时间少的，运行效率会有显著提升。一定要先明确SRT是抢占的。先给出时间为顺序的图：

 

1. A先运行至2，B到达等待。

2. A运行到3结束，B开始运行。

3. B开始运行，运行到4时，C进程到达，且C只需要4，此时B还需要5。所以先运行C，B继续等待。

4. C运行时间点到达6时，D到达，D需要5，进入等待，排在B后。

5. C运行结束，此时时间点是8，E到达，运行时间只要2，小于等待的BD，直接运行。

6. C运行结束，B开始运行。

7. B运行结束，D开始运行。

以表格的形式展现：

 

 

轮转RR
轮转也称时间片技术（time slicing，SL），对于轮转法，最重要的是时间片的长度。轮转算法以一个周期（q）产生中断，当中断发生时，当前运行的程序置于就绪队列（队尾）中，然后基于FCFS选择下一个就绪作业运行。在这里我们以时间片q=1举例。

q=1，所以一次只能运行一个时间片。

0：A1运转（右标表示运行了几个）

1：A2运转

2：B1运转，A3等待（B开始）

3：A3运转，B2等待

4：B2运转，C1等待，（A结束）

5：C1运转，B3等待（C开始）

6：B3运转，D1等待，C2等待

7：D1运转，C2等待，B4等待（D开始）

8：C2运行，B4等待，E1等待，D2等待

9：B4运行，E1等待，D2等待，C3等待

10：E1运行，D2等待，C3等待，B5等待（E开始）

11：D2运行，C3等待，B5等待，E2等待

12：C3运行，B5等待，E2等待，D3等待

13：B5运行，E2等待，D3等待，C4等待

14：E2运行，D3等待，C4等待，B6等待

15：D3运行，C4等待，B6等待（E结束）

16：C4运行，B6等待，D4等待

17：B6运行，D4等待（C结束）

18：D5运行，D6等待（B结束）

19：D6运行

20：D结束

表格展示：

 

 

高响应比优先HRRN
高响应比优先调度算法

高响应比优先调度算法主要用于作业调度，该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。 

响应比的变化规律可描述为：

响应比=（等待时间+服务时间）/服务时间

根据公式可知：

当作业的等待时间相同时，则要求服务时间越短，其响应比越高，有利于短作业。

当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。

对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。克服了饥饿状态，兼顾了长作业。


一 了解进程资源图
Markdown编辑器用的还不是太熟，表格中插入图片这事还没学会，纠结着在Word中总结了下，然后截个图放在下面供大家参考：

图和表示的内容

二 化简资源分配图
方法步骤
第一步：先看系统还剩下多少资源没分配，再看有哪些进程是不阻塞（“不阻塞”即：系统有足够的空闲资源分配给它）的
第二步：把不阻塞的进程的所有边都去掉，形成一个孤立的点，再把系统分配给这个进程的资源回收回来
第三步：看剩下的进程有哪些是不阻塞的，然后又把它们逐个变成孤立的点。
第四步：最后，所有的资源和进程都变成孤立的点。这样的图就叫做“可完全简化”。
如果一个图可完全简化，则不会产生死锁；如果一个图不可完全简化（即：图中还有“边”存在），则会产生死锁。这就是“死锁定理”。 

实例
进程资源图

第一步：先看R1资源，它有三个箭头是向外的，因此它一共给进程分配了3个资源，此时，R1没有空闲的资源剩余。
第二步：再看R2资源，它有一个箭头是向外的，因此它一共给进程分配了1个资源，此时，R2还剩余一个空闲的资源没分配。
第三步：看完资源，再来看进程，先看进程P2，它只申请一个R1资源，但此时R1资源已经用光了，所以，进程P2进入阻塞状态，因此，进程P2暂时不能化成孤立的点。
第四步：再看进程P1，它只申请一个R2资源，此时，系统还剩余一个R2资源没分配，因此，可以满足P1的申请。这样，进程P1便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P1的所有的边去掉，变成一个孤立的点，如下图所示：
进程资源图2

第五步：进程P1运行完后，释放其所占有的资源（2个R1资源和1个R2资源），系统回收这些资源后，空闲的资源便变成2个R1资源和1个R2资源，由于进程P2一直在申请一个R1资源，所以此时，系统能满足它的申请。这样，进程P2便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P2的所有的边都去掉，化成一个孤立的点，变成下图： 
进程资源图3
由于这个资源分配图可完全简化，因此，不会产生死锁。 
而如果资源分配图中的点，最终不能够化成孤立的点，则进程资源图不能够完全简化，从而会发生死锁。
