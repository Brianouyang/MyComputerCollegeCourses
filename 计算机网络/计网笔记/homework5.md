# 传输层

> 姓名:陈扬
>
> 学号:17150011001

8、9、10、13、14、19、20、22、23、24, 28、30、31、33、34、35、38、39、41、46、47、49、58、61、64、66、70、72 ,73

---

5-08 为什么说 UDP 是面向报文的，而 TCP 是面向字节流的？

> UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。

> 应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。

---

5-09 端口的作用是什么？为什么端口号要划分为三种？

> 端口的作用是对TCP/IP体系的应用进程进行统一的标志，使运行不同操作系统的计算机的应用进程能够互相通信。
>
> 按照端口号的大小分类，可分为如下几类：
>
> 1、熟知端口（WellKnownPorts）：从0到1023，它们紧密绑定（binding）于一些服务。通常这些端口的通讯明确表明了某种服务的协议。例如：80端口实际上总是HTTP通讯。
>
> 2、登记端口（RegisteredPorts）：从1024到49151。松散地绑定于一些服务。也就是说有许多服务绑定于这些端口，这些端口同样用于许多其它目的,使用这类端口必须按照IANA的规定手续登记。例如：许多系统处理动态端口从1024左右开始.
>
> 3、短暂端口 (动态和/或私有端口)（Dynamicand/orPrivatePorts）：从49152到65535。这类端口仅在客户端进程运行时才动态选择,且只是暂时使用.

---

5-10 试说明运输层中伪首部的作用

>伪首部(pseudo header)，通常有TCP伪首部和UDP伪首部。在UDP/TCP伪首部中，包含32位源IP地址，32位目的IP地址，8位填充0，8位协议，16位TCP/UDP长度。通过伪首部的校验，UDP可以确定该数据报是不是发给本机的，通过首部协议字段，UDP可以确认有没有误传。
>
>伪首部并非TCP&UDP数据报中实际的有效成分。伪首部是一个虚拟的[数据结构](http://baike.baidu.com/view/9900.htm)，其中的信息是从数据报所在IP分组头的分组头中提取的，既不向下传送也不向上递交，而仅仅是为计算[校验和](http://baike.baidu.com/view/1969592.htm)。

---

5-13 一个 UDP 用户数据报的数据字段为 8192 字节。在链路层要使用以太网来传送。试问应当划分为几个 IP 数据报片？说明每一个 IP 数据报片的数据字段长度和片偏移字段的值。

>UDP数据包文长度==8192+8=8300B
>
>以太网数据报最大长度为1500B,IP首部为20B,则一个IP数据报可以承载1480B数据,
>
>8200==1480*5+800
>
>所以一共需要6个IP数据报
>
>第一个数据报的片偏移字节为0, 第二个数据报片偏移字节为1480,以此类推,第六个数据报片偏移为1480X5==7400B,
>
>1~5个数据报长度为1480B,最后一个数据报长度为800B

---

5-14 一个UDP用户数据报的首部的十六进制表示是:`06 32 00 45 00 1C E2 17`。试求源端口、目的端口、用户数据报的总长度、数据部分长度。这个用户数据报是从客户发送给服务器还是从服务器发送给客户？使用 UDP 的这个服务器程序是什么？

> ![image-20191227211831230](https://cy-1256894686.cos.ap-beijing.myqcloud.com/2019-12-27-131831.png)
>
> 由此可知,源端口为:06 32=1586;目的端口为:00 45=68;
>
> 用户数据报的总长度:00 1C==28 byte;数据部分长度为28-8=20byte
>
> 由于目标端口<1023,为熟知端口,所以可以判断是客户端发送给服务器,
>
> 69端口对应的应用是TFTP

----

5-19 试证明：当用 n 比特进行分组的编号时，若接收窗口等于 1（即只能按序接收分组），则仅在发送窗口不超过 $2^n-1$ 时，连续 ARQ 协议才能正确运行。窗口单位是分组。

> 发送窗口与接收窗口大小之和<=$2^n$时,ARQ协议才能正常运行
>
> ![image-20191227212451156](https://cy-1256894686.cos.ap-beijing.myqcloud.com/2019-12-27-132451.png)

> 证明是不会证明了,我考试记住这个结论好了



----

5-20 在连续 ARQ 协议中，若发送窗口等于 7, 则发送端在开始时可连续发送 7 个分组.因此，在每一分组发出后，都要置一个超时计时器。现在计算机里只有一个硬时钟设这 7 个分组发出的时间分别为$ t_0,t_1,...,t_6$ ,且$t_{out}$ 都一样大。试问如何实现这 7 个超时计时器（这叫软时钟法）?

> ![image-20191227212932893](https://cy-1256894686.cos.ap-beijing.myqcloud.com/2019-12-27-132933.png)

---

5-22 主机 A 向主机 B 发送一个很长的文件，其长度为 L 字节。假定 TCP 使用的 MSS 为1460 字节。

(1) 在 TCP 的序号不重复使用的条件下，L 的最大值是多少？

> 可能的序号数为$2^{32}$个,即L的最大长度可以为$2^{32}B->4GB$

(2) 假定使用上面计算出的文件长度，而运输层、网络层和数据链路层所用的首部开销共66字节,链路的数据率为10Mbit/s，试求这个文件所需的最短发送时间。

> $2^{32}/1460≈2900000$,即需要发送2900000帧
>
> 首部开销为66X2900000=191400000 byte
>
> 发送的中字节数为=$2^{32}+191400000\;byte$
>
> 速率:10Mbit/s==1.25MB/s
>
> $\frac{2^{32}+191400000\;byte}{1.25MB/s}≈1hour$,需要大约一个小时

---

5-23 主机 A 向主机 B 连续发送了两个 TCP 报文段，其序号分别是 70 和 100。试问：
(1)第一个报文段携带了多少字节的数据？

> 100 - 70 = 30 byte 字节数据

(2) 主机 B 收到第一个报文段后发回的确认中的确认号应当是多少？

> ACK = 100

(3) 如果 B 收到第二个报文段后发回的确认中的确认号是 180, 试问 A 发送的第二个报文段中的数据有多少字节？

> 180 - 100 = 80 byte

(4) 如果 A 发送的第一个报文段丢失了，但第二个报文段到达了 B。B 在第二个报文段到达后向 A 发送确认。试问这个确认号应为多少？

> ACK 为 70 (因为第一个丢了,所以服务器返回是一个 ACK = 70 )

---

5-24 一个 TCP 连接下面使用 256 kbit/s的链路,其端到端时延为128ms。经测试，发现吞吐量只有 120 kbit/s。试问发送窗口W是多少?(提示:可以有两种答案，取决于接收端发出确认的时机。）

> 第一种情况是：RTT等于256ms(=128ms×2)。一次最大发送量等于窗口值，且发射时间等于tms。每发送一次都得停下来期待再次得到下一窗口的确认，以得到新的发送许可。
> $$
> throughput=\frac{W}{\frac{W}{256kbit/s}+128ms\times 2}=120kbits/s
> $$
> 解得发送窗口:
> $$
> W=58000bit
> $$
>
> ---
>
> 第二种情况,使用pipline,连续传送,累积确认:
> $$
> throughput=\frac{W}{128ms\times 2}=120kbit/s
> $$
> 解得:
> $$
> W=30000bit
> $$
> 

----

5-28 主机 A 向主机 B 发送 TCP 报文段，首部中的源端口是 m 而目的端口是 n。当 B 向 A发送回信时，其 TCP 报文段的首部中的源端口和目的端口分别是什么？

> 源端口:n
>
> 目的端口:m

---

5-31通信信道带宽为1Gbit/s,端到端传播时延为10ms。TCP的发送窗口为65535字节。试问：可能达到的最大吞吐量是多少？信道的利用率是多少？

>    L=65536×8+40×8=524600
>
> 
>
> L=65536×8+40×8=524600
>
>    C=109b/s
>
>    L/C=0.0005246s
>
>    Td=10×10-3s
>
>    0.02104864
>
>    Throughput=L/(L/C+2×Td)=524600/0.0205246=25.5Mb/s
>
>    Efficiency=(L/C)//(L/C+2×D)=0.0255
>
>   最大吞吐量为25.5Mb/s。信道利用率为25.5/1000=2.55%

---

5-33 假定 TCP 在开始建立连接时，发送方设定超时重传时间 RTO=6 秒。
(1) 当发送方收到对方的连接确认报文段时，测量出 RTT 样本值为 1.5 秒。试计算现在的 RTO 值。

> $$
> RTT_S=1.5s\\
> RTT_D=1.5/2s\\
> RTO=RTT_S+RTT_D\times 4=4.5s
> $$

 (2) 当发送方发送数据报文段并收到确认时，测量出 RTT 样本值为 2.5 秒。试计算现在的 RTO 值。

> $$
> \alpha=1/8\\
> \beta=1/4 \\
> RTT^{New}=2.5s\\
> RTT_S^{New}=(1-\alpha)\times RTT_S^{Old}+\alpha\times{RTT^{New}}=1.625s \\
> RTT_D^{New}=(1-\beta)\times RTT_D^{Old}+\beta\times|RTT_S^{New}-RTT^{New}|=0.78s\\
> RTO=RTT_S^{New}+RTT_D^{New}\times 4=4.75s
> $$
>
> 

----

5-34 已知第一次测得 TCP 的往返时间 RTT 是 30 ms。接着收到了三个确认报文段，用它们测量出的往返时间样本 RTT 分别是：26 ms,32 ms 和 24 ms。设 a=0.1。试计算每次的新的加权平均往返时间值 RTTs。讨论所得出的结果。

> $$
> \alpha=0.1\\
> RTT_S^{New}=(1-\alpha)\times RTT_S^{Olde}+\alpha\times RTT^{New}
> \\
> RTT_S^1=29.6ms
> \\
> RTT_S^2=29.8ms
> \\
> RTT_S^3=29.3ms
> $$
>
> 可以看出$RTT$变化即便很大,$RTT_S$的变化仍然很小
>
> 

---

5-35 试计算一个包括五段链路的运输连接的单程端到端时延。五段链路中有两段是卫星链路，有三段是广域网链路。每条卫星链路又由上行链路和下行链路两部分组成。可以取这两部分的传播时延之和为 250 ms。每一个广域网的范围为 1500 km，其传播时延 可按150000km/s来计算。各数据链路速率为48kbit/s,帧长为960 bit/s

> 广域网的传播时延:(1500km)/(150000km/s)=10ms
>
> 每个数据链路的传输时延:(960bit)/(48000bit)=20ms
>
> 单程时延=$10ms\times 3+250ms\times 2+20ms\times 5 =960ms$
>
> 

---

5-38 设 TCP 的 ssthresh 的初始值为 8（单位为报文段）。当拥塞窗口上升到 12 时网络发生了超时，TCP 使用慢开始和拥塞避免。试分别求出第 1 轮次到第 15 轮次传输的各拥塞窗口大小。你能说明拥塞窗口每一次变化的原因吗？

> (1)  慢开始：在主机刚刚开始发送报文段时，可先将拥塞窗口   cwnd   设置为一个最大报文段   MSS   的数值。作用：在每收到一个对新的报文段的确认后，将拥塞窗口增加至多一个   MSS   的数值。用这样的方法逐步增大发送端的拥塞窗口   cwnd  ，可以使分组注入到网络的速率更加合理。
>
> (2)  拥塞避免：当拥塞窗口值大于慢开始门限时，停止使用慢开始算法而改用拥塞避免算法。作用：拥塞避免算法使发送端的拥塞窗口每经过一个往返时延  RTT  就增加一个  MSS  的大小。
>
> (3)   当  cwnd<ssthresh  时，拥塞窗口按指数规律增长；
>
> -  当  cwnd>ssthresh  时，拥塞窗口按线性规律增长；
> -  当发生超时时，   ssthresh  的值更新为发送窗口数值的一半。
> -  第一轮次拥塞窗口的大小为1，第15轮次的拥塞窗口为9，根据慢开始算法当在第4个时间轮次上升到8时（此时拥塞窗口为8）改为执行拥塞避免算法（加法增大），由已知得当到第8个轮次的时候拥塞窗口为12此时网络发生了超时，更新后的ssthresh值变为6（发送窗口12的一半）拥塞窗口再重新设置为 1，并执行慢开始算法第9个轮次为1，到第12个轮次窗口数变为6开始加法增大到第15个轮次时拥塞窗口为9.  
>
>   因此，拥塞窗口的大小分别为：

<div align="center">
  <table border="1" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td valign="top"><p>
            <span>次数</span>
          </p>
        </td><td valign="top"><p>
            <span>1</span>
          </p>
        </td><td valign="top"><p>
            <span>2</span>
          </p>
        </td><td valign="top"><p>
            <span>3</span>
          </p>
        </td><td valign="top"><p>
            <span>4</span>
          </p>
        </td><td valign="top"><p>
            <span>5</span>
          </p>
        </td><td valign="top"><p>
            <span>6</span>
          </p>
        </td><td valign="top"><p>
            <span>7</span>
          </p>
        </td><td valign="top"><p>
            <span>8</span>
          </p>
        </td><td valign="top"><p>
            <span>9</span>
          </p>
        </td><td valign="top"><p>
            <span>10</span>
          </p>
        </td><td valign="top"><p>
            <span>11</span>
          </p>
        </td><td valign="top"><p>
            <span>12</span>
          </p>
        </td><td valign="top"><p>
            <span>13</span>
          </p>
        </td><td valign="top"><p>
            <span>14</span>
          </p>
        </td><td valign="top"><p>
            <span>15</span>
          </p>
        </td></tr>
      <tr>
        <td valign="top"><p>
            <span>拥塞窗口大小</span>
          </p>
        </td><td valign="top"><p>
            <span>1</span>
          </p>
        </td><td valign="top"><p>
            <span>2</span>
          </p>
        </td><td valign="top"><p>
            <span>4</span>
          </p>
        </td><td valign="top"><p>
            <span>8</span>
          </p>
        </td><td valign="top"><p>
            <span>9</span>
          </p>
        </td><td valign="top"><p>
            <span>10</span>
          </p>
        </td><td valign="top"><p>
            <span>11</span>
          </p>
        </td><td valign="top"><p>
            <span>12</span>
          </p>
        </td><td valign="top"><p>
            <span>1</span>
          </p>
        </td><td valign="top"><p>
            <span>2</span>
          </p>
        </td><td valign="top"><p>
            <span>4</span>
          </p>
        </td><td valign="top"><p>
            <span>6</span>
          </p>
        </td><td valign="top"><p>
            <span>7</span>
          </p>
        </td><td valign="top"><p>
            <span>8</span>
          </p>
        </td><td valign="top"><p>
            <span>9</span>
          </p>
        </td></tr>
      <tr>
        <td valign="top"><p></p>
        </td><td colspan="4" valign="top"><p>
            <span>慢开始</span>
          </p>
        </td><td colspan="4" valign="top"><p>
            <span>拥塞避免</span>
          </p>
        </td><td colspan="3" valign="top"><p>
            <span>慢开始</span>
          </p>
        </td><td colspan="4" valign="top"><p>
            <span>拥塞避免</span>
          </p>
        </td></tr>
      <tr>
        <td valign="top"><p></p>
        </td><td colspan="4" valign="top"><p>
            <span>指数增长</span>
          </p>
        </td><td colspan="4" valign="top"><p>
            <span>线性增长</span>
          </p>
        </td><td colspan="3" valign="top"><p>
            <span>指数增长</span>
          </p>
        </td><td colspan="4" valign="top"><p>
            <span>线性增长</span>
          </p>
        </td></tr>
    </tbody>
  </table>
</div>

---

5-39 TCP 的拥塞窗口 cwnd 大小与传输轮次 n 的关系如下所示：

![](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-12-27-070009.png)

(1) 试画出如图 5-25 所示的拥塞窗口与传输轮次的关系曲线。

>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>

(2) 指明 TCP 工作在慢开始阶段的时间间隔。

(3) 指明 TCP 工作在拥塞避免阶段的时间间隔。

(4) 在第 16 轮次和第 22 轮次之后发送方是通过收到三个重复的确认还是通过超时检测到丢失了报文段？

(5) 在第 1 轮次、第 18 轮次和第 24 轮次发送时，门限 ssthresh 分别被设置为多大？ 

(6) 在第几轮次发送出第 70 个报文段？

>
>
>
>
>
>
>
>
>
>
>
>
>

(7) 假定在第 26 轮次之后收到了三个重复的确认，因而检测出了报文段的丢失，那么拥塞窗口 cwnd 和门限 ssthresh 应设置为多大？

>

---

5-41 用 TCP 传送 512 字节的数据。设窗口为 100 字节，而 TCP 报文段每次也是传送 100 字节的数据。再设发送方和接收方的起始序号分别选为 100 和 200, 试画出类似于图 5-28 的工作示意图。从连接建立阶段到连接释放都要画上。

> ![img](https://cy-1256894686.cos.ap-beijing.myqcloud.com/2019-12-28-081234.png)
>
> 

---

5-46 试用具体例子说明为什么在运输连接建立时要使用三报文握手。说明如不这样做可能会出现什么情况。

> 弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。
>
> 第一次握手：客户端发送网络包，服务端收到了。
>
> 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
>
> 第二次握手：服务端发包，客户端收到了。
>
> 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
>
> 第三次握手：客户端发包，服务端收到了。
>
> 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。
>
> 因此，需要三次握手才能确认双方的接收与发送能力是否正常。
>
> 试想如果是用两次握手，则会出现下面这种情况：
>
> > 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。

---

5-47 一客户向服务器请求建立 TCP 连接。客户在 TCP 连接建立的三报文握手中的最后个报文段中捎带上一些数据，请求服务器发送一个长度为 L 字节的文件。假定: 

(1)客户和服务器之间的数据传送速率是R字节/秒,客户与服务器之间的往返时间是 RTT（固定值）。

(2) 服务器发送的 TCP 报文段的长度都是 M 字节，而发送窗口大小是 nM 字节。

(3) 所有传送的报文段都不会出现差错（无重传），客户收到服务器发来的报文段后

就及时发送确认。

(4) 所有的协议首部开销都可忽略，所有确认报文段和连接建立阶段的报文段的长度

都可忽略（即忽略这些报文段的发送时间）。

试证明，从客户开始发起连接建立到接收服务器发送的整个文件所需的时间 T 是：

![image-20191227150332794](https://cy-1256894686.cos.ap-beijing.myqcloud.com/cy/2019-12-27-070333.png)

(提示：求证的第一个等式发生在发送窗口较大的情况，可以连续把文件发送完。求证的第二个等式发生在发送窗口较小的情况，发送几个报文段后就必须停顿下来，等收到确认后再继续发送。建议先画出双方交互的时间图，然后再进行推导。)

> 
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 

---

5-49 下面是以十六进制格式存储的一个 UDP 首部

CB 84 00 0D 00 1C 00 1C

试问：
(1) 源端口号是什么？CB 84=52100

(2) 目的端口号是什么？00 0D = 13

(3) 这个用户数据报的总长度是多少？00 1C =28byte

(4) 数据长度是多少？28 - 8 = 20 byte

(5) 这个分组是从客户到服务器方向的，还是从服务器到客户方向的？

目的端口号<1024,是熟知端口,所以可以判断是客户发给服务器

(6) 客户进程是什么？

13端口是daytime process

> ![image-20191227211831230](https://cy-1256894686.cos.ap-beijing.myqcloud.com/2019-12-28-081623.png)

---

5-58 TCP 在时间为 4:30:20（即 4 点 30 分 20 秒）发送了一个报文段。由于没有收到确认，因此在 4:30:25 重传了前面这个报文段，并在 4:30:27 收到了确认。若以前的 RTT 值是 4 秒，根据 Kam 算法，新的 RTT 值是多少？

> 根据karn算法,只要TCP报文重传了,就不采用往返时间样本,RRT不发生变化仍然是4s

---

5-61 在本题中列出的 8 种情况下，画出发送窗口的变化，并标明可用窗口的位置。已知主机 A 要向主机 B 发送 3 KB 的数据。

在 TCP 连接建立后，A 的发送窗口大小是 2 KB。A 的初始序号是 0。

 (1)一开始 A 发送 1 KB 的数据。

 (2) 接着 A 就一直发送数据，直到把发送窗口用完。

 (3) 发送方 A 收到对第 1000 号字节的确认报文段。

 (4) 发送方 A 再发送 850 B 的数据。

 (5) 发送方 A 收到 ack=900 的确认报文段。

 (6) 发送方 A 收到对第 2047 号字节的确认报文段。

 (7) 发送方 A 把剩下的数据全部都发送完。

 (8) 发送方 A 收到 ack=3072 的确认报文段。

> 
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 

---

5-64 : TCP 连接处于 FN-WAIT-1 状态。以下的事件相继发生：

收到 ACK 报文段。

收到 FN 报文段

发生了超时。

在以上的每一个事件之后,连接的状态是什么?在每一个事件之后发生的动作是什么？

> 1. TCP客户端不发送任何报文
> 2. TCP客户端发送ACK报文段看,进入TIME-WAIT state
> 3. 当发生超时,经过2MSL后,TCP客户端进入CLOSE state

---

5-66 主机 A 通过 TCP 连接向 B 发送一个很长的文件，因此这需要分成很多个报文段来发送。假定某一个 TCP 报文段的序号是 x，那么下一个报文段的序号是否就是 x+1 呢？

>不一定,只有但当前报文段中数据长度n=1时才成立
>
>否则应该是x+n

---

5-70假定用TCP协议在40Gbit/s的线路上传送数据

(1) 如果 TCP 充分利用了线路的带宽，那么需要多长的时间 TCP 会发生序号绕回？

> 40Gbit/s==$5\times 10^9 byte/s$
>
> TCP序号有32bit,
> $$
> \frac{2^{32}byte}{5\times 10^9byte/s}=860ms
> $$
> 需要860ms,TCP 会发生序号绕回

(2) 假定现在 TCP 的首部中采用了时间戳选项。时间戳占用了 4 字节，共 32 位.每隔一定的时间（这段时间叫做一个嘀嗒）时间戳的数值加 1。假定设计的时间戳是每隔 859 微秒，时间戳的数值加 1。试问要经过多少时间才发生时间戳数值的绕回？

> $$
> 2^{32} \times 860 \times 10^{-6}s=43\; day
> $$

---

5-72 已知 TCP 的接收窗口大小是 600（单位是字节，为简单起见以后就省略了单位），已经确认了的序号是 300。试问，在不断地接收报文段和发送确认报文段的过程中，接收窗口也可能会发生变化（增大或缩小）。请用具体例子（指出接收方发送的确认报文段中的重要信息）来说明哪些情况是可能发生的，而哪些情况是不允许发生的.

> 
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 

---

5-73 在上题中，如果接收方突然因某种原因不能够再接收数据了，可以立即向发送方发送把接收窗口置为零的报文段（即 rwnd=0)。这时会导致接收窗口的前沿后退。试问这种情况是否允许？

> 
>
> 
>
> 